<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_11) on Fri Jan 23 19:58:24 CET 2009 -->
<TITLE>
Query
</TITLE>

<META NAME="date" CONTENT="2009-01-23">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Query";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../jpl/PrologException.html" title="class in jpl"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../jpl/Term.html" title="class in jpl"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?jpl/Query.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Query.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jpl</FONT>
<BR>
Class Query</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>jpl.Query</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.util.Enumeration</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Query</B><DT>extends java.lang.Object<DT>implements java.util.Enumeration</DL>
</PRE>

<P>
A Query instance is created by an application in order to query the Prolog database
 (or to invoke a built-in predicate).
 It is initialised with a
 Compound (or Atom) denoting the goal which is to be called, and also contains assorted private state
 relating to solutions.  In some future version, it may contain details of the module
 in which the goal is to be called.<p>
 A Query is either open or closed: when closed, it has no connection to the Prolog system;
 when open, it is linked to an active goal within a Prolog engine.<p>
 The Query class implements the Enumeration interface,
 through which one can obtain successive solutions.  The Enumeration
 hasMoreElements() method returns true if the call or redo succeeded (otherwise
 false), and if the call or redo did succeed, the nextElement() method returns
 a Hashtable representing variable bindings; the elements in the
 Hashtable are Terms, indexed by the (String) names of the Variables with which they are associated.
 For example, if <i>p(a)</i> and <i>p(b)</i> are facts in the Prolog
 database, then the following is equivalent to printing all
 the solutions to the Prolog query <i>p(X)</i>:
 <pre>
 Variable X = new Variable("X");
 Term arg[] = { X };
 Query    q = new Query("p", arg);
 
 while (q.hasMoreElements()){
     Term bound_to_x = ((Hashtable) q.nextElement()).get("X");
     System.out.println(bound_to_x);
 }
 </pre>
 Make sure to close the Query (using the close() method) if you do not need
 any further solutions which it may have.
 It is safe (although redundant) to close a Query whose solutions are already exhausted,
 or which is already closed.
 
 To obtain just one solution from a Query, use the oneSolution() method.
 
 To obtain all solutions, use the allSolutions() method.
 
 To obtain at most N solutions, use the nSolutions() method.
 
 To determine merely whether the Query is provable,
 use the hasSolution() method
 (i.e. has at least one solution).
 <hr>
 <i>
 Copyright (C) 2007  Paul Singleton<p>
 Copyright (C) 1998  Fred Dushin
 <p>
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.
 <p>
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Library Public License for more details.<p>
 </i>
 <hr>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(java.lang.String)">Query</A></B>(java.lang.String&nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor builds a Query from the given Prolog source text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(java.lang.String, jpl.Term)">Query</A></B>(java.lang.String&nbsp;text,
      <A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(java.lang.String, jpl.Term[])">Query</A></B>(java.lang.String&nbsp;text,
      <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If text denotes an atom, this constructor is shorthand for
 <font face="monospace">new Query(new Compound(name,args))</font>,
 but if text denotes a term containing N query (?) symbols
 and there are N args, each query is replaced by its corresponding arg
 to provide the new Query's goal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(jpl.Term)">Query</A></B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor creates a Query whose goal is the specified Term.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#abort()">abort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#allSolutions()">allSolutions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls the Query's goal to exhaustion
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#allSolutions(java.lang.String)">allSolutions</A></B>(java.lang.String&nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#allSolutions(java.lang.String, jpl.Term[])">allSolutions</A></B>(java.lang.String&nbsp;text,
             <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying Term params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#allSolutions(jpl.Term)">allSolutions</A></B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query whose goal is the given Term,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#args()">args</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use .goal().args() instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to close an open query before its solutions are exhausted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#debugString()">debugString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#getSolution()">getSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns a java.util.Hashtable, which represents
 a set of bindings from the names of query variables to terms within the solution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#getSubstWithNameVars()">getSubstWithNameVars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../jpl/Compound.html" title="class in jpl">Compound</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#goal()">goal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Compound (hence perhaps an Atom) which is the goal of this Query</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasMoreElements()">hasMoreElements</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method implements part of the java.util.Enumeration
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasMoreSolutions()">hasMoreSolutions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns true if JPL was able to initiate a "call" of this
 Query within a Prolog engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasSolution()">hasSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method will attempt to call this Query's goal within an available Prolog engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasSolution(java.lang.String)">hasSolution</A></B>(java.lang.String&nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query from the given Prolog source text
 and calls it at most once, returning true if a solution was found, else false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasSolution(java.lang.String, jpl.Term[])">hasSolution</A></B>(java.lang.String&nbsp;text,
            <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its corresponding arg
 to provide the new Query's goal: the resulting Query is called as described above.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasSolution(jpl.Term)">hasSolution</A></B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning true if a solution was found, else false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#isOpen()">isOpen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isOpen() returns true iff the query is open.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#name()">name</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use .goal().name() instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nextElement()">nextElement</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method implements part of the java.util.Enumeration
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nextSolution()">nextSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns a java.util.Hashtable, which represents
 a binding from the names of query variables to terms within the solution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nSolutions(long)">nSolutions</A></B>(long&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls the Query's goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nSolutions(java.lang.String, long)">nSolutions</A></B>(java.lang.String&nbsp;text,
           long&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nSolutions(java.lang.String, jpl.Term[], long)">nSolutions</A></B>(java.lang.String&nbsp;text,
           <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params,
           long&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nSolutions(jpl.Term, long)">nSolutions</A></B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal,
           long&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query whose goal is the given Term,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#oneSolution()">oneSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first solution, if any, as a (possibly empty) Hashtable of variablename-to-term bindings, else null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#oneSolution(java.lang.String)">oneSolution</A></B>(java.lang.String&nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query from the given Prolog source text fragment,
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#oneSolution(java.lang.String, jpl.Term[])">oneSolution</A></B>(java.lang.String&nbsp;text,
            <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its respective param
 to provide the goal of this query:
 the resulting goal is then called (at most once) and the first solution, if there is one, is returned as a (possibly empty) Hashtable, else null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#oneSolution(jpl.Term)">oneSolution</A></B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#open()">open</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#query()">query</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use .hasSolution() instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#rewind()">rewind</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a crude String representation of a Query.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Query(jpl.Term)"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;t)</PRE>
<DL>
<DD>This constructor creates a Query whose goal is the specified Term.
 The Query is initially closed.
 <b>NB</b>  Creating an instance of the Query class does not
 result in a call to a Prolog engine.
 <b>NB</b>  The goal can be a Compound or an Atom (Atom extends Compound), but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the goal of this Query</DL>
</DL>
<HR>

<A NAME="Query(java.lang.String, jpl.Term[])"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(java.lang.String&nbsp;text,
             <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;args)</PRE>
<DL>
<DD>If text denotes an atom, this constructor is shorthand for
 <font face="monospace">new Query(new Compound(name,args))</font>,
 but if text denotes a term containing N query (?) symbols
 and there are N args, each query is replaced by its corresponding arg
 to provide the new Query's goal.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the name of the principal functor of this Query's goal<DD><CODE>args</CODE> - the arguments of this Query's goal</DL>
</DL>
<HR>

<A NAME="Query(java.lang.String, jpl.Term)"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(java.lang.String&nbsp;text,
             <A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;arg)</PRE>
<DL>
</DL>
<HR>

<A NAME="Query(java.lang.String)"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(java.lang.String&nbsp;text)</PRE>
<DL>
<DD>This constructor builds a Query from the given Prolog source text.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Prolog source text of this Query</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="name()"><!-- --></A><H3>
name</H3>
<PRE>
public final java.lang.String <B>name</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use .goal().name() instead.</I>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the name of this Query's goal (redundant, deprecated)</DL>
</DD>
</DL>
<HR>

<A NAME="args()"><!-- --></A><H3>
args</H3>
<PRE>
public final <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[] <B>args</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use .goal().args() instead.</I>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the arguments of this Query's goal (redundant, deprecated)</DL>
</DD>
</DL>
<HR>

<A NAME="goal()"><!-- --></A><H3>
goal</H3>
<PRE>
public final <A HREF="../jpl/Compound.html" title="class in jpl">Compound</A> <B>goal</B>()</PRE>
<DL>
<DD>Returns the Compound (hence perhaps an Atom) which is the goal of this Query
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a Term representing the goal of this Query</DL>
</DD>
</DL>
<HR>

<A NAME="isOpen()"><!-- --></A><H3>
isOpen</H3>
<PRE>
public final boolean <B>isOpen</B>()</PRE>
<DL>
<DD>isOpen() returns true iff the query is open.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the query is open, otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="hasMoreSolutions()"><!-- --></A><H3>
hasMoreSolutions</H3>
<PRE>
public final boolean <B>hasMoreSolutions</B>()</PRE>
<DL>
<DD>This method returns true if JPL was able to initiate a "call" of this
 Query within a Prolog engine.  It is designed to be used
 with the nextSolution() method to retrieve one or
 more substitutions in the form of Hashtables.  To iterate through
 all the solutions to a Query, for example, one might write
 <pre>
 Query q = // obtain Query reference
 while (q.hasMoreSolutions()) {
     Hashtable solution = q.nextSolution();
     // process solution...
 }
 </pre>
 To ensure thread-safety, you should wrap sequential calls to
 this method in a synchronized block, using the static
 lock method to obtain the monitor.
 <pre>
 Query q = // obtain Query reference
 synchronized ( jpl.Query.lock() ){
     while ( q.hasMoreElements() ){
          Hashtable solution = q.nextSolution();
          // process solution...
     }
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the Prolog query succeeds; otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="open()"><!-- --></A><H3>
open</H3>
<PRE>
public final void <B>open</B>()</PRE>
<DL>
<DD>This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.  It is designed to be used
 with the getSolution() and close() methods to retrieve one or
 more substitutions in the form of Hashtables.
 <pre>
 Query q = // obtain Query reference
 Hashtable soln;
 q.open();
 while ((soln = q.getSolution()) != null) {
      // process solution...
 }
 </pre>
 <p>
 If this method is called on an already-open Query,
 or if the query cannot be set up for whatever reason,
 then a JPLException will be thrown.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSolution()"><!-- --></A><H3>
getSolution</H3>
<PRE>
public final java.util.Hashtable <B>getSolution</B>()</PRE>
<DL>
<DD>This method returns a java.util.Hashtable, which represents
 a set of bindings from the names of query variables to terms within the solution.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable,
 say, named "X", one can obtain the Term bound to "X" in the solution
 by looking up "X" in the Hashtable.
 <pre>
 Variable x = new Variable("X");
 Query q = // obtain Query reference (with x in the Term array)
 while (q.hasMoreSolutions()) {
     Hashtable solution = q.nextSolution();
     // make t the Term bound to "X" in the solution
     Term t = (Term) solution.get("X");
     // ...
 }
 </pre>
 Programmers should obey the following rules when using this method.
 <menu>
 <li> The nextSolution() method should only be called after the
 hasMoreSolutions() method returns true; otherwise a JPLException
 will be raised, indicating that the Query is no longer open.
 <li> The nextSolution() and hasMoreSolutions() should be called
 in the same thread of execution, for a given Query
 instance.
 </menu>
 
 This method will throw a JPLException if Query is not open.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A Hashtable representing a substitution, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getSubstWithNameVars()"><!-- --></A><H3>
getSubstWithNameVars</H3>
<PRE>
public final java.util.Hashtable <B>getSubstWithNameVars</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextSolution()"><!-- --></A><H3>
nextSolution</H3>
<PRE>
public final java.util.Hashtable <B>nextSolution</B>()</PRE>
<DL>
<DD>This method returns a java.util.Hashtable, which represents
 a binding from the names of query variables to terms within the solution.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable,
 say, named "X", one can obtain the Term bound to "X" in the solution
 by looking up "X" in the Hashtable.
 <pre>
 Variable x = new Variable("X");
 Query q = // obtain Query reference (with x in the Term array)
 while (q.hasMoreSolutions()) {
     Hashtable solution = q.nextSolution();
     // make t the Term bound to "X" in the solution
     Term t = (Term) solution.get("X");
     // ...
 }
 </pre>
 Programmers should obey the following rules when using this method.
 <menu>
 <li> The nextSolution() method should only be called after the
 hasMoreSolutions() method returns true; otherwise a JPLException
 will be raised, indicating that the Query is no longer open.
 <li> The nextSolution() and hasMoreSolutions() should be called
 in the same thread of execution, for a given Query
 instance.
 </menu>
 
 This method will throw a JPLException if Query is not open.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A Hashtable representing a substitution.</DL>
</DD>
</DL>
<HR>

<A NAME="hasMoreElements()"><!-- --></A><H3>
hasMoreElements</H3>
<PRE>
public final boolean <B>hasMoreElements</B>()</PRE>
<DL>
<DD>This method implements part of the java.util.Enumeration
 interface.  It is a wrapper for hasMoreSolutions.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>hasMoreElements</CODE> in interface <CODE>java.util.Enumeration</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the Prolog query yields a (or another) solution, else false.</DL>
</DD>
</DL>
<HR>

<A NAME="nextElement()"><!-- --></A><H3>
nextElement</H3>
<PRE>
public final java.lang.Object <B>nextElement</B>()</PRE>
<DL>
<DD>This method implements part of the java.util.Enumeration
 interface.  It is a wrapper for nextSolution.
 <p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>nextElement</CODE> in interface <CODE>java.util.Enumeration</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A Hashtable representing a substitution.</DL>
</DD>
</DL>
<HR>

<A NAME="rewind()"><!-- --></A><H3>
rewind</H3>
<PRE>
public final void <B>rewind</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public final void <B>close</B>()</PRE>
<DL>
<DD>This method can be used to close an open query before its solutions are exhausted. 
 It is called automatically when solutions are exhausted, i.e. when hasMoreSolutions() fails.
 Calling close() on an already closed Query is harmless (has no effect).<p>
 
 Here is one way to get the first three solutions to a Query:
 <pre>
 Query q = new Query(predicate, args);
 Hashtable sub1 = (Hashtable) q.nextSolution();
 Hashtable sub2 = (Hashtable) q.nextSolution();
 Hashtable sub3 = (Hashtable) q.nextSolution();
 q.close();
 </pre><p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="allSolutions()"><!-- --></A><H3>
allSolutions</H3>
<PRE>
public final java.util.Hashtable[] <B>allSolutions</B>()</PRE>
<DL>
<DD>calls the Query's goal to exhaustion
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)
 <b>NB</b> in JPL 1.0.1, this method (inconsistently) returned null when a Query had no solutions;
 in JPL 2.x onwards it returns an empty array (thus the length of the array is, in every case,
 the quantity of solutions).<p>
 <b>NB</b> in JPL 1.0.1, bindings were keyed (awkwardly) by Variable instances;
 in JPL 2.x onwards they are keyed by the (String) names of variables,
 which is consistent with the Term type being just a concrete syntax for terms (and hence queries).<p></DL>
</DD>
</DL>
<HR>

<A NAME="allSolutions(jpl.Term)"><!-- --></A><H3>
allSolutions</H3>
<PRE>
public static final java.util.Hashtable[] <B>allSolutions</B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal)</PRE>
<DL>
<DD>This static method creates a Query whose goal is the given Term,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
 Throws JPLException if goal is neither a jpl.Atom nor a jpl.Compound.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>goal</CODE> - the goal of this Query
<DT><B>Returns:</B><DD>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)</DL>
</DD>
</DL>
<HR>

<A NAME="allSolutions(java.lang.String)"><!-- --></A><H3>
allSolutions</H3>
<PRE>
public static final java.util.Hashtable[] <B>allSolutions</B>(java.lang.String&nbsp;text)</PRE>
<DL>
<DD>This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - a Prolog source text fragment denoting a goal
<DT><B>Returns:</B><DD>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)</DL>
</DD>
</DL>
<HR>

<A NAME="allSolutions(java.lang.String, jpl.Term[])"><!-- --></A><H3>
allSolutions</H3>
<PRE>
public static final java.util.Hashtable[] <B>allSolutions</B>(java.lang.String&nbsp;text,
                                                       <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params)</PRE>
<DL>
<DD>If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying Term params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion,
 and returns an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found).
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of the goal and params are the args;
 the resulting goal is then called as above.
 This letter mode is redundant, deprecated (informally), and retained only for backward compatibility.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters<DD><CODE>params</CODE> - terms to be substituted for the respective questionmarks in the query text
<DT><B>Returns:</B><DD>an array of zero or more Hashtables of zero or more variablename-to-term bindings (each Hashtable represents a solution, in the order in which they were found)</DL>
</DD>
</DL>
<HR>

<A NAME="nSolutions(long)"><!-- --></A><H3>
nSolutions</H3>
<PRE>
public final java.util.Hashtable[] <B>nSolutions</B>(long&nbsp;n)</PRE>
<DL>
<DD>calls the Query's goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array of Hashtables (possibly none), each of which is a solution
 (in the order in which they were found) of the Query; at most 'n' solutions will be found and returned.
 <b>NB</b> in JPL 1.0.1, this method (inconsistently) returned null when a Query had no solutions;
 in JPL 2.x onwards it returns an empty array (thus the length of the array is, in every case,
 the quantity of solutions).<p>
 <b>NB</b> in JPL 1.0.1, bindings were keyed (awkwardly) by Variable instances;
 in JPL 2.x onwards they are keyed by the (String) names of variables,
 which is consistent with the Term type being just a concrete syntax for terms (and hence queries).<p></DL>
</DD>
</DL>
<HR>

<A NAME="nSolutions(jpl.Term, long)"><!-- --></A><H3>
nSolutions</H3>
<PRE>
public static final java.util.Hashtable[] <B>nSolutions</B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal,
                                                     long&nbsp;n)</PRE>
<DL>
<DD>This static method creates a Query whose goal is the given Term,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
 Throws JPLException if goal is neither a jpl.Atom nor a jpl.Compound.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>goal</CODE> - the goal of this Query</DL>
</DD>
</DL>
<HR>

<A NAME="nSolutions(java.lang.String, long)"><!-- --></A><H3>
nSolutions</H3>
<PRE>
public static final java.util.Hashtable[] <B>nSolutions</B>(java.lang.String&nbsp;text,
                                                     long&nbsp;n)</PRE>
<DL>
<DD>This static method creates a Query from the given Prolog source text fragment,
 calls it to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - a Prolog source text fragment denoting a goal</DL>
</DD>
</DL>
<HR>

<A NAME="nSolutions(java.lang.String, jpl.Term[], long)"><!-- --></A><H3>
nSolutions</H3>
<PRE>
public static final java.util.Hashtable[] <B>nSolutions</B>(java.lang.String&nbsp;text,
                                                     <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params,
                                                     long&nbsp;n)</PRE>
<DL>
<DD>If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols and there are N accompanying params,
 this static method replaces each questionmark symbol by its respective param,
 calls the resulting goal to exhaustion or until N solutions are found, whichever is sooner,
 and returns an array containing (as possibly empty Hashtables of variablename-to-term bindings) every found solution (in the order in which they were found).
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of the goal and params are the args;
 the resulting goal is then called as above.
 This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters<DD><CODE>params</CODE> - terms to be substituted for the respective questionmarks in the query text</DL>
</DD>
</DL>
<HR>

<A NAME="oneSolution()"><!-- --></A><H3>
oneSolution</H3>
<PRE>
public final java.util.Hashtable <B>oneSolution</B>()</PRE>
<DL>
<DD>Returns the first solution, if any, as a (possibly empty) Hashtable of variablename-to-term bindings, else null.
 
 This method will throw a JPLException if this Query is already open (and the Query will remain open as before).
 Otherwise, upon return, the Query will be closed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the first solution, if the query has one, as a (possibly empty) Hashtable.
 If the return value is null, this means that the Query has no solutions.<p></DL>
</DD>
</DL>
<HR>

<A NAME="oneSolution(jpl.Term)"><!-- --></A><H3>
oneSolution</H3>
<PRE>
public static final java.util.Hashtable <B>oneSolution</B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal)</PRE>
<DL>
<DD>This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.
 The goal can be a jpl.Atom or a jpl.Compound, but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>goal</CODE> - the goal of this Query</DL>
</DD>
</DL>
<HR>

<A NAME="oneSolution(java.lang.String)"><!-- --></A><H3>
oneSolution</H3>
<PRE>
public static final java.util.Hashtable <B>oneSolution</B>(java.lang.String&nbsp;text)</PRE>
<DL>
<DD>This static method creates a Query from the given Prolog source text fragment,
 and calls it at most once, returning the first solution, if there is one, as a (possibly empty) Hashtable, else null.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - a Prolog source text fragment denoting a goal</DL>
</DD>
</DL>
<HR>

<A NAME="oneSolution(java.lang.String, jpl.Term[])"><!-- --></A><H3>
oneSolution</H3>
<PRE>
public static final java.util.Hashtable <B>oneSolution</B>(java.lang.String&nbsp;text,
                                                    <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params)</PRE>
<DL>
<DD>If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its respective param
 to provide the goal of this query:
 the resulting goal is then called (at most once) and the first solution, if there is one, is returned as a (possibly empty) Hashtable, else null.
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of the goal and params are the args;
 the resulting goal is then called as above.
 This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters<DD><CODE>params</CODE> - terms to be substituted for the respective questionmarks in the query text</DL>
</DD>
</DL>
<HR>

<A NAME="query()"><!-- --></A><H3>
query</H3>
<PRE>
public final boolean <B>query</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use .hasSolution() instead.</I>
<P>
<DD>This method will attempt to call this Query's goal within an available Prolog engine.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the provability of the Query, i.e. 'true' if it has at least
 one solution, 'false' if the call fails without finding a solution.<p>
 
 Only the first solution (if there is one) will be found;
 any bindings will be discarded, and the Query will be closed.<p>
 This method will throw a JPLException if this Query is already open.</DL>
</DD>
</DL>
<HR>

<A NAME="hasSolution()"><!-- --></A><H3>
hasSolution</H3>
<PRE>
public final boolean <B>hasSolution</B>()</PRE>
<DL>
<DD>This method will attempt to call this Query's goal within an available Prolog engine.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the provability of the Query, i.e. 'true' if it has at least
 one solution, 'false' if the call fails without finding a solution.<p>
 
 Only the first solution (if there is one) will be found;
 any bindings will be discarded, and the Query will be closed.<p>
 This method will throw a JPLException if this Query is already open.</DL>
</DD>
</DL>
<HR>

<A NAME="hasSolution(jpl.Term)"><!-- --></A><H3>
hasSolution</H3>
<PRE>
public static final boolean <B>hasSolution</B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;goal)</PRE>
<DL>
<DD>This static method creates a Query (whose goal is the specified Term)
 and calls it at most once, returning true if a solution was found, else false.
 The goal can be a jpl.Atom or a jpl.Compound, but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>goal</CODE> - the goal of this Query</DL>
</DD>
</DL>
<HR>

<A NAME="hasSolution(java.lang.String)"><!-- --></A><H3>
hasSolution</H3>
<PRE>
public static final boolean <B>hasSolution</B>(java.lang.String&nbsp;text)</PRE>
<DL>
<DD>This static method creates a Query from the given Prolog source text
 and calls it at most once, returning true if a solution was found, else false.
 Throws PrologException containing error(syntax_error(_),_) if text is invalid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the goal of this Query, as Prolog source text</DL>
</DD>
</DL>
<HR>

<A NAME="hasSolution(java.lang.String, jpl.Term[])"><!-- --></A><H3>
hasSolution</H3>
<PRE>
public static final boolean <B>hasSolution</B>(java.lang.String&nbsp;text,
                                        <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;params)</PRE>
<DL>
<DD>If text denotes (in traditional Prolog source syntax) a term containing N questionmark (?) symbols
 and there are N params, each questionmark symbol is replaced by its corresponding arg
 to provide the new Query's goal: the resulting Query is called as described above.
 
 Otherwise, if text denotes an atom, this static method creates a Query
 where text is the name of its goal and args are its args;
 it then calls this goal (at most once) and returns true if a solution was found, else false.
 This latter mode is redundant, deprecated (informally), and retained only for backward compatibility.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Prolog source text of a goal, in which questionmarks are regarded as substitutible parameters<DD><CODE>params</CODE> - terms to be substituted for the respective questionmarks in the query text</DL>
</DD>
</DL>
<HR>

<A NAME="abort()"><!-- --></A><H3>
abort</H3>
<PRE>
public final int <B>abort</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a crude String representation of a Query.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a crude String representation of a Query</DL>
</DD>
</DL>
<HR>

<A NAME="debugString()"><!-- --></A><H3>
debugString</H3>
<PRE>
public java.lang.String <B>debugString</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>
<P>
<DD>Returns a debug-friendly representation of a Query
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a debug-friendly representation of a Query</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../jpl/PrologException.html" title="class in jpl"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../jpl/Term.html" title="class in jpl"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?jpl/Query.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Query.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
